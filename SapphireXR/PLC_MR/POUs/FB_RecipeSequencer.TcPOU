<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.8">
  <POU Name="FB_RecipeSequencer" Id="{eaa1ede0-1851-426e-9c35-61099dc6c976}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RecipeSequencer
VAR_INPUT
	nRcpIndex	: INT;
END_VAR
VAR_OUTPUT

END_VAR
VAR
	// for FB_Sequencer Variable
	// 	aController : ARRAY[1..26] OF FB_RampGenerator; //MFC EPC 0 ~ 5V
	// 	aController_PV : ARRAY[1..29] OF INT;
	aGasController : ARRAY[1..29] OF FB_RampGenerator;
	aGasController_PV : ARRAY[1..29] OF INT;
	i 	: INT;
	nRcpRampTime	: INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[nRcpRampTime := RCP.aRecipe[nRcpIndex].iRecipe[2]; // Current Recipe Step Ramp Time 

(* Write a Controller MFC / EPC *)
FOR i:= 1 TO 26 DO
	IF GVL_IO.aMaxValueController[i] <> 0 THEN
		GVL_IO.aController[i].nState := 10;
		GVL_IO.aController[i].nRampTime := RCP.aRecipe[nRcpIndex].iRecipe[2]; //Current Recipe Step Ramp Time
		GVL_IO.aController[i].rTargetValue := RCP.aRecipe[nRcpIndex].rRecipe[i] / GVL_IO.aMaxValueController[i] * GVL_IO.KL3464MaxValueH; //Input Set Value
		GVL_IO.aAnalogOutputIO[i] := LREAL_TO_INT(GVL_IO.aController[i].rControlValue);
		
		GVL_IO.aController_PV[i] := REAL_TO_INT(GVL_IO.aAnalogInputIO[i] / GVL_IO.KL3464MaxValueH * GVL_IO.aMaxValueController[i]);
		GVL_IO.aController[i]();
	END_IF
END_FOR

FOR i:=27 TO 29 DO
	CASE i OF
		 27 : // Heater Controller 
			IF GVL_IO.aMaxValueController[i]<> 0 THEN
				GVL_IO.aController[i].nState := 10;
			END_IF	

			IF ( GVL_IO.aController_CV[i] > 10 ) THEN
				P11_E3508.bHeaterOn := TRUE;
			ELSE
				P11_E3508.bHeaterOn := FALSE;
			END_IF
	
			GVL_IO.aController[i].nRampTime := GVL_IO.aController_RampTime[i];
			GVL_IO.aController[i].rTargetValue := GVL_IO.aController_TV[i];
			P11_E3508.wControlValue := LREAL_TO_WORD(GVL_IO.aController[i].rControlValue); //Write to Temperature Controller
			
			GVL_IO.aController_PV[i] := WORD_TO_INT(P11_E3508.wE3508_PV);
			GVL_IO.aController_CV[i] := WORD_TO_INT(P11_E3508.wControlValue);
			GVL_IO.aController[i]();
			
		28 : // Pressure Controller
			IF (GVL_IO.aController_TV[i] >= 0 ) THEN
				GVL_IO.aController[i].nState := 10; //START
			END_IF
			
			GVL_IO.aController[i].nRampTime := GVL_IO.aController_RampTime[i];
			GVL_IO.aController[i].rTargetValue := GVL_IO.aController_TV[i];
			P12_IQ_PLUS.wControlValue := LREAL_TO_WORD(GVL_IO.aController[i].rControlValue); //Write to Pressure Controller
			
			GVL_IO.aController_PV[i] := WORD_TO_INT(P12_IQ_PLUS.wCDG2_PV);
			GVL_IO.aController_CV[i] := WORD_TO_INT(P12_IQ_PLUS.wControlValue);
			GVL_IO.aController[i]();
			
		29 : // Rotation Controller
			IF (GVL_IO.aController_TV[i] >= 0 ) THEN
				GVL_IO.aController[i].nState := 10; //START
			END_IF
			
			GVL_IO.aController[i].nRampTime := GVL_IO.aController_RampTime[i];
			GVL_IO.aController[i].rTargetValue := GVL_IO.aController_TV[i];
			P15_RotationOperation.rControlValue := LREAL_TO_REAL(GVL_IO.aController[i].rControlValue); //Write to Rotation Controller (rpm)
			
			GVL_IO.aController_PV[i] := P15_RotationOperation.nConvertedRotation_PV;
			GVL_IO.aController_CV[i] := REAL_TO_INT(P15_RotationOperation.rControlValue);
			GVL_IO.aController[i]();		
	END_CASE
END_FOR


(* Solenoid Valve Mapping *)
GVL_IO.aOutputSolValve[1].0 := RCP.aRecipe[nRcpIndex].dRecipe.0; //V01 Hyd. Carrier
GVL_IO.aOutputSolValve[1].1 := RCP.aRecipe[nRcpIndex].dRecipe.1; //V02
GVL_IO.aOutputSolValve[1].2 := RCP.aRecipe[nRcpIndex].dRecipe.2; //V03
GVL_IO.aOutputSolValve[1].3 := RCP.aRecipe[nRcpIndex].dRecipe.3; //V04
GVL_IO.aOutputSolValve[1].4 := RCP.aRecipe[nRcpIndex].dRecipe.4; //V05
GVL_IO.aOutputSolValve[1].6 := RCP.aRecipe[nRcpIndex].dRecipe.5; //V07
GVL_IO.aOutputSolValve[1].7 := RCP.aRecipe[nRcpIndex].dRecipe.6; //V08
GVL_IO.aOutputSolValve[1].9 := RCP.aRecipe[nRcpIndex].dRecipe.7; //V10
GVL_IO.aOutputSolValve[1].10 := RCP.aRecipe[nRcpIndex].dRecipe.8; //V11
GVL_IO.aOutputSolValve[1].12 := RCP.aRecipe[nRcpIndex].dRecipe.9; //V13
GVL_IO.aOutputSolValve[1].13 := RCP.aRecipe[nRcpIndex].dRecipe.10; //V14
GVL_IO.aOutputSolValve[1].15 := RCP.aRecipe[nRcpIndex].dRecipe.11; //V16
GVL_IO.aOutputSolValve[2].0 := RCP.aRecipe[nRcpIndex].dRecipe.12; //V17
GVL_IO.aOutputSolValve[2].2 := RCP.aRecipe[nRcpIndex].dRecipe.13; //V19
GVL_IO.aOutputSolValve[2].3 := RCP.aRecipe[nRcpIndex].dRecipe.14; //V20
GVL_IO.aOutputSolValve[2].5 := RCP.aRecipe[nRcpIndex].dRecipe.15; //V22
GVL_IO.aOutputSolValve[2].6 := RCP.aRecipe[nRcpIndex].dRecipe.16; //V23
GVL_IO.aOutputSolValve[2].7 := RCP.aRecipe[nRcpIndex].dRecipe.17; //V24
GVL_IO.aOutputSolValve[2].8 := RCP.aRecipe[nRcpIndex].dRecipe.18; //V25
GVL_IO.aOutputSolValve[2].9 := RCP.aRecipe[nRcpIndex].dRecipe.19; //V26
GVL_IO.aOutputSolValve[2].10 := RCP.aRecipe[nRcpIndex].dRecipe.20; //V27
GVL_IO.aOutputSolValve[2].11 := RCP.aRecipe[nRcpIndex].dRecipe.21; //V28
GVL_IO.aOutputSolValve[2].12 := RCP.aRecipe[nRcpIndex].dRecipe.22; //V29
GVL_IO.aOutputSolValve[2].13 := RCP.aRecipe[nRcpIndex].dRecipe.23; //V30
GVL_IO.aOutputSolValve[2].14 := RCP.aRecipe[nRcpIndex].dRecipe.24; //V31
GVL_IO.aOutputSolValve[2].15 := RCP.aRecipe[nRcpIndex].dRecipe.25; //V32]]></ST>
    </Implementation>
    <LineIds Name="FB_RecipeSequencer">
      <LineId Id="25" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="129" Count="0" />
      <LineId Id="36" Count="5" />
      <LineId Id="243" Count="0" />
      <LineId Id="197" Count="45" />
      <LineId Id="196" Count="0" />
      <LineId Id="244" Count="0" />
      <LineId Id="195" Count="0" />
      <LineId Id="132" Count="26" />
      <LineId Id="131" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>