<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4026.11">
  <POU Name="P90_Interlock" Id="{c8b81d81-de46-4c7a-a894-4387b2cd9bf7}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P90_Interlock
VAR_INPUT
	bRecipeRunning : BOOL;
	RecipeStopped : BOOL;
	ManualOperation : BOOL;
	bInductionHeaterMC	: BOOL;
	bThermalBathMC		: BOOL;
	bVacuumPumpMC 		: BOOL;
	bLineHeaterMC 		: BOOL; 
END_VAR
VAR_OUTPUT
	bCoverOperationEnable	: BOOL;
	bDORVacEnable			: BOOL;
	bDORAtmEnable			: BOOL;
	bPowerResetSwitch		: BOOL;
	bMainPowerMonitor		: BOOL;
	bRecipeEnable			: BOOL;
	AlarmTrig				: BOOL;
	WarningTrig				: BOOL;
END_VAR	
VAR
	bMaintKey				: BOOL;
	bSafetyGasState			: BOOL;
	bAlarmState				: BOOL;
	bPowerResetLED			: BOOL;
	bUPSMode				: BOOL;

	bAirPressureSensor		: BOOL;
	bWaterFlowSensor		: BOOL;
	
	tAlarmDelay_A			: TIME; //아날로그 디바이스 지연시간
	tAlarmDelay_D			: TIME; //디지털 디바이스 지연시간
	
	fbDeviationCheck		:ARRAY[1..29] OF FB_DeviationCheck;
	wDeviceAlarmEnable		: DWORD;
	wDeviceWarningEnable	: DWORD;
	bDeviationAlarm			: BOOL;
	bDeviationWarning		: BOOL;
	wDeviationAlarm			: DWORD;
	wDeviationWarning		: DWORD;

	fbSensorLimitCheck		:ARRAY[1..4] OF FB_SensorLimitCheck;
	wLimitAlarmEnable		: DWORD;
	wLimitWarningEnable		: DWORD;
	bLimitAlarm				: BOOL;
	bLimitWarning			: BOOL;
	wLimitAlarm				: DWORD;
	wLimitWarning			: DWORD;
	
	fbFaultCheck			:ARRAY[1..6] OF FB_FaultCheck;
	wAlarmEnable			: DWORD;
	wWarningEnable			: DWORD;
	bFaultAlarm				: BOOL;
	bFaultWarning			: BOOL;
	wAlarm					: DWORD;
	wWarning				: DWORD;
	
	bMaintKeyTest			: BOOL; //Test Variable
	i	: INT;
	j 	: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Read from Device*)
//Interlock Variable Set
bMaintKey := GVL_IO.aDigitalInputIO[1].0;
bPowerResetSwitch := GVL_IO.aDigitalInputIO[1].1;
bMainPowerMonitor := GVL_IO.aDigitalInputIO[7].5;
bAirPressureSensor	:= GVL_IO.aDigitalInputIO[2].0; //Normally Contacted
bWaterFlowSensor	:= GVL_IO.aDigitalInputIO[2].1;

//Sinal Tower Set
IF bMaintKeyTest THEN //bMaintKey 변경
	P92_Maintenance.nCaseSignalTower		:= 5; //Signal Tower White - Maintenance
ELSIF (bMaintKey = FALSE) AND MAIN.bOperationMode = FALSE THEN
	P92_Maintenance.nCaseSignalTower		:= 4; //Signal Tower Blue - Idle
END_IF

//알람 지연 시간 변환
tAlarmDelay_A := REAL_TO_TIME(GVL_IO.aInterlockSet[3]*1000); // UI Setting Analog Delay Time Value(Miliseconde)
tAlarmDelay_D := REAL_TO_TIME(GVL_IO.aInterlockSet[4]*1000);

//Controller Deviation Monitoring - MFC/EPC
IF (bMaintKey = FALSE) THEN
	
	FOR i := 1 TO 26 DO
		wDeviceAlarmEnable := SHR(GVL_IO.aInterlockEnable[2], (i+2)); //오늘쪽 쉬프트 연산
		wDeviceWarningEnable := SHR(GVL_IO.aInterlockEnable[3], (i+2));
		fbDeviationCheck[i](
			bAlarmEnable := wDeviceAlarmEnable.0,
			bWarningEnable := wDeviceWarningEnable.0,
			fCurrentValue := GVL_IO.aController_PV[i],
			fControlValue := GVL_IO.aController_CV[i],
			fMaxValue := GVL_IO.aMaxValueController[i],
			fAlarmTreshold := GVL_IO.aInterlockSet[1],
			fWarningTreshold := GVL_IO.aInterlockSet[2],
			tAlarmDelay := tAlarmDelay_A,
			bDeviationAlarm => bDeviationAlarm, //알람 출력
			bDeviationWarning => bDeviationWarning // 주의(Warning) 출력
			);
		IF bDeviationAlarm THEN		
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			P92_Maintenance.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i+2));
			wDeviationAlarm.0 := TRUE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i+2));
		ELSE
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i+2));
			wDeviationAlarm.0 := FALSE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i+2));	
		END_IF
		
		IF bDeviationWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; // Warning Trig
			P92_Maintenance.nCaseSignalTower := 2; // Signal Tower Yellow - Warning
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i+2));
			wDeviationWarning.0 := TRUE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i+2));
		ELSE
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i+2));
			wDeviationWarning.0 := FALSE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i+2));
		END_IF
	END_FOR
	//Controller Deviation Monitoring - Temp, Pressure, Rotation
	FOR i := 27 TO 29 DO
		wDeviceAlarmEnable := SHR(GVL_IO.aInterlockEnable[2], (i-27)); //오늘쪽 쉬프트 연산, -27은 어레이 변수 옵셋값
		wDeviceWarningEnable := SHR(GVL_IO.aInterlockEnable[3], (i-27));
		fbDeviationCheck[i](
			bAlarmEnable := wDeviceAlarmEnable.0,
			bWarningEnable := wDeviceWarningEnable.0,
			fCurrentValue := GVL_IO.aController_PV[i],
			fControlValue := GVL_IO.aController_CV[i],
			fMaxValue := GVL_IO.aMaxValueController[i],
			fAlarmTreshold := GVL_IO.aInterlockSet[1],
			fWarningTreshold := GVL_IO.aInterlockSet[2],
			tAlarmDelay := tAlarmDelay_A,
			bDeviationAlarm => bDeviationAlarm, //알람 출력
			bDeviationWarning => bDeviationWarning // 주의(Warning) 출력
			);
		IF bDeviationAlarm THEN		
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			P92_Maintenance.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i-27));
			wDeviationAlarm.0 := TRUE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i-27));
		ELSE
			wDeviationAlarm := ROR(GVL_IO.aInterlock[3], (i-27));
			wDeviationAlarm.0 := FALSE;
			GVL_IO.aInterlock[3] := ROL(wDeviationAlarm, (i-27));
		END_IF
		
		IF bDeviationWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; // Warning Trig
			P92_Maintenance.nCaseSignalTower := 2; // Signal Tower Yellow - Warning
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i-27));
			wDeviationWarning.0 := TRUE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i-27));
		ELSE
			wDeviationWarning := ROR(GVL_IO.aInterlock[5], (i-27));
			wDeviationWarning.0 := FALSE;
			GVL_IO.aInterlock[5] := ROL(wDeviationWarning, (i-27));
		END_IF	
	END_FOR
	//Gas Pressure Alarm N2, H2, NH3, SiH4
	FOR i := 1 TO 4 DO
		wLimitAlarmEnable := SHR(GVL_IO.aInterlockEnable[4], (i-1)); //오늘쪽 쉬프트 연산, 은 어레이 변수 옵셋값
		wLimitWarningEnable := SHR(GVL_IO.aInterlockEnable[5], (i-1));
		fbSensorLimitCheck[i](
			bAlarmEnable := wLimitAlarmEnable.0,
			bWarningEnable := wLimitWarningEnable.0,
			fCurrentValue := GVL_IO.aMonitoring_PV[(i+3)],
			fAlarmTreshold := GVL_IO.aInterlockSet[5],
			fWarningTreshold := GVL_IO.aInterlockSet[6],
			tAlarmDelay := tAlarmDelay_D,
			bLimitAlarm => bLimitAlarm, //알람 출력
			bLimitWarning => bLimitWarning //주의(Warning) 출력
			);	
		IF bLimitAlarm THEN		
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			P92_Maintenance.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			//팝업 표시
			wLimitAlarm := ROR(GVL_IO.aInterlock[2], (i-1));
			wLimitAlarm.0 := TRUE;
			GVL_IO.aInterlock[2] := ROL(wLimitAlarm, (i-1));
			//대시보드 표시
			wLimitAlarm := ROR(GVL_IO.aInterlock[1], (i*2));
			wLimitAlarm.0 := TRUE;
			GVL_IO.aInterlock[1] := ROL(wLimitAlarm, (i*2));
		ELSE
			//팝업 표시
			wLimitAlarm := ROR(GVL_IO.aInterlock[2], (i-1));
			wLimitAlarm.0 := FALSE;
			GVL_IO.aInterlock[2] := ROL(wLimitAlarm, (i-1));
			//대시보드 표시
			wLimitAlarm := ROR(GVL_IO.aInterlock[1], (i*2));
			wLimitAlarm.0 := FALSE;
			GVL_IO.aInterlock[1] := ROL(wLimitAlarm, (i*2));
		END_IF
		
		IF bLimitWarning THEN		
			GVL_IO.aInterlock[1].1 := TRUE; //Warning Trig
			P92_Maintenance.nCaseSignalTower := 2; // Signal Tower YELLOW - Warning
			//팝업 표시
			wLimitWarning := ROR(GVL_IO.aInterlock[4], (i-1));
			wLimitWarning.0 := TRUE;
			GVL_IO.aInterlock[4] := ROL(wLimitWarning, (i-1));
			//대시보드 표시
			wLimitWarning := ROR(GVL_IO.aInterlock[1], (i*2)+1);
			wLimitWarning.0 := TRUE;
			GVL_IO.aInterlock[1] := ROL(wLimitWarning, (i*2)+1);
		ELSE
			//팝업 표시
			wLimitWarning := ROR(GVL_IO.aInterlock[4], (i-1));
			wLimitWarning.0 := FALSE;
			GVL_IO.aInterlock[4] := ROL(wLimitWarning, (i-1));
			//대시보드 표시
			wLimitWarning := ROR(GVL_IO.aInterlock[1], (i*2)+1);
			wLimitWarning.0 := FALSE;
			GVL_IO.aInterlock[1] := ROL(wLimitWarning, (i*2)+1);
		END_IF
	END_FOR
	
	//Cooling Water, Over
	FOR i := 5 TO 8 DO
		wLimitAlarmEnable := SHR(GVL_IO.aInterlockEnable[4], (i-1)); //오늘쪽 쉬프트 연산, 은 어레이 변수 옵셋값
		wLimitWarningEnable := SHR(GVL_IO.aInterlockEnable[5], (i-1));

		fbSensorLimitCheck[i](
			bAlarmEnable := wLimitAlarmEnable.0,
			bWarningEnable := wLimitWarningEnable.0,
			fCurrentValue := GVL_IO.aMonitoring_PV[(i+3)],
			fAlarmTreshold := (GVL_IO.aInterlockSet[i+2] + 10),
			fWarningTreshold := GVL_IO.aInterlockSet[i+2],
			tAlarmDelay := tAlarmDelay_D,
			bLimitAlarm => bLimitAlarm, //알람 출력
			bLimitWarning => bLimitWarning //주의(Warning) 출력
			);	
	END_FOR

	//Device Fault Check - Pneumatic, Heater, Pump, Motor, GC Door, RC Door
	FOR i := 1 TO 6 DO
		wAlarmEnable := SHR(GVL_IO.aInterlockEnable[4], (i+7));
		wWarningEnable := SHR(GVL_IO.aInterlockEnable[5], (i+7));
		fbFaultCheck[i](
			bAlarmEnable := wAlarmEnable.0,
			bWarningEnable := wWarningEnable.0,
			bCurrentState := ,
			tAlarmDelay := tAlarmDelay_D,
			bAlarm => bFaultAlarm,
			bWarning => bFaultWarning
			);
		IF bFaultAlarm THEN
			GVL_IO.aInterlock[1].0 := TRUE; //Alarm Trig
			P92_Maintenance.nCaseSignalTower := 1; // Signal Tower RED - Alarm
			//팝업 표시
			wAlarm := ROR(GVL_IO.aInterlock[2], (i+3));
			wAlarm.0 := TRUE;
			GVL_IO.aInterlock[2] := ROL(wAlarm, (i+3));
		END_IF
		IF bFaultWarning THEN
			GVL_IO.aInterlock[1].1 := TRUE; //Warning Trig
			P92_Maintenance.nCaseSignalTower := 2; // Signal Tower YELLOW - Warning
			//팝업 표시
			wAlarm := ROR(GVL_IO.aInterlock[4], (i+3));
			wAlarm.0 := TRUE;
			GVL_IO.aInterlock[4] := ROL(wAlarm, (i+3));
		END_IF
	END_FOR
	
	IF GVL_IO.aInterlockEnable[1].0 THEN //알람 리셋 버턴을 눌렀을 때
		GVL_IO.aInterlock[1].0 := FALSE; //Alarm Trig Reset
		GVL_IO.aInterlockEnable[1].0 := FALSE; //버턴 초기화
		P92_Maintenance.nCaseSignalTower := 4; // Signal Tower Blue - Idle
	END_IF
	IF GVL_IO.aInterlockEnable[1].1 THEN //주의 리셋 버턴을 눌렀을 때
		GVL_IO.aInterlock[1].1 := FALSE; //Warmomg Trig Reset
		GVL_IO.aInterlockEnable[1].1 := FALSE; //버턴 초기화
		P92_Maintenance.nCaseSignalTower := 4; // Signal Tower Blue - Idle
	END_IF
	
ELSE
	//매인터넌스 키가 ON 되었을 때 MC(Induction, Bath, Pump, L_Heater) 조작 허용
	P92_Maintenance.nCaseSignalTower := 4; // Signal Tower Blue - Idle
	GVL_IO.aDigitalOutputIO[3].0 := bInductionHeaterMC;
	GVL_IO.aDigitalOutputIO[3].1 := bThermalBathMC;
	GVL_IO.aDigitalOutputIO[3].2 := bVacuumPumpMC;
	GVL_IO.aDigitalOutputIO[3].3 := bLineHeaterMC;
END_IF


// For Test Value
bSafetyGasState := TRUE;

// AND Valve01 = FALSE(H2) AND Valve02 = FALSE(H2) AND Valve03(SiH4) AND Valve04(NH2)
// All MO-Source ByPass Stat
bAlarmState := TRUE;

bCoverOperationEnable := bSafetyGasState AND bAlarmState AND P17_DOROperation.isDOROnState = FALSE; //For Test -P16
// bCoverOpenEnable := ing_Racipe AND bAlarmClear AND isInductionHeater = FAULSE

bDORVacEnable := P16_CoverOperation.isCoverClosed AND bAlarmState AND bSafetyGasState AND P17_DOROperation.isDOROnState = FALSE; //For Test -P17
// add : Vacuum Pump ON
bDORAtmEnable := bAlarmState AND bSafetyGasState AND P17_DOROperation.isDOROnState = TRUE;
// Susceptor Temperature, Vacuum Range > 700Torr

//bRecipeEnable := bMaintKey=FALSE AND bRecipeRunning=FALSE AND P16_CoverOperation.isCoverClosed AND P12_IQ_PLUS.bPumpOn;
bRecipeEnable := TRUE;

(* Out to Device*)
GVL_IO.aDigitalOutputIO[3].7 := bPowerResetLED;
GVL_IO.aDigitalOutputIO[2].4 := bUPSMode;
]]></ST>
    </Implementation>
    <LineIds Name="P90_Interlock">
      <LineId Id="139" Count="0" />
      <LineId Id="300" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="304" Count="1" />
      <LineId Id="307" Count="0" />
      <LineId Id="303" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="296" Count="0" />
      <LineId Id="298" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="301" Count="1" />
      <LineId Id="299" Count="0" />
      <LineId Id="353" Count="1" />
      <LineId Id="322" Count="0" />
      <LineId Id="479" Count="0" />
      <LineId Id="478" Count="0" />
      <LineId Id="438" Count="0" />
      <LineId Id="653" Count="0" />
      <LineId Id="1038" Count="0" />
      <LineId Id="656" Count="38" />
      <LineId Id="705" Count="38" />
      <LineId Id="654" Count="0" />
      <LineId Id="906" Count="25" />
      <LineId Id="951" Count="2" />
      <LineId Id="950" Count="0" />
      <LineId Id="954" Count="0" />
      <LineId Id="932" Count="3" />
      <LineId Id="1018" Count="0" />
      <LineId Id="936" Count="2" />
      <LineId Id="955" Count="0" />
      <LineId Id="958" Count="1" />
      <LineId Id="957" Count="0" />
      <LineId Id="960" Count="0" />
      <LineId Id="939" Count="3" />
      <LineId Id="966" Count="6" />
      <LineId Id="945" Count="1" />
      <LineId Id="905" Count="0" />
      <LineId Id="1062" Count="0" />
      <LineId Id="1036" Count="0" />
      <LineId Id="1039" Count="0" />
      <LineId Id="1043" Count="1" />
      <LineId Id="1057" Count="0" />
      <LineId Id="1045" Count="8" />
      <LineId Id="1041" Count="1" />
      <LineId Id="1060" Count="1" />
      <LineId Id="1040" Count="0" />
      <LineId Id="1065" Count="0" />
      <LineId Id="1067" Count="1" />
      <LineId Id="1070" Count="0" />
      <LineId Id="1072" Count="4" />
      <LineId Id="1071" Count="0" />
      <LineId Id="1078" Count="0" />
      <LineId Id="1081" Count="4" />
      <LineId Id="1079" Count="1" />
      <LineId Id="1087" Count="6" />
      <LineId Id="1086" Count="0" />
      <LineId Id="1066" Count="0" />
      <LineId Id="1064" Count="0" />
      <LineId Id="1027" Count="8" />
      <LineId Id="1026" Count="0" />
      <LineId Id="1037" Count="0" />
      <LineId Id="753" Count="0" />
      <LineId Id="759" Count="0" />
      <LineId Id="755" Count="3" />
      <LineId Id="754" Count="0" />
      <LineId Id="655" Count="0" />
      <LineId Id="1054" Count="0" />
      <LineId Id="138" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="242" Count="0" />
      <LineId Id="51" Count="2" />
      <LineId Id="83" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="275" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="274" Count="0" />
      <LineId Id="276" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="210" Count="0" />
      <LineId Id="415" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>